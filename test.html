<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WIESZJAK - Particle Effects</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --ui-bg: rgba(255, 255, 255, 0.1);
      --ui-text: #fff;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: var(--bg);
      font-family: 'Segoe UI', sans-serif;
    }

    canvas {
      display: block;
    }

    /* UI Controls */
    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      background: var(--ui-bg);
      padding: 10px;
      border-radius: 50px;
      backdrop-filter: blur(5px);
      z-index: 10;
    }

    button {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.3);
      color: var(--ui-text);
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    button:hover {
      background: rgba(255,255,255,0.2);
      border-color: #fff;
    }

    button.active {
      background: #fff;
      color: #000;
      font-weight: bold;
      box-shadow: 0 0 15px rgba(255,255,255,0.5);
    }
  </style>
</head>
<body>

  <canvas id="stage"></canvas>

  <div class="controls">
    <button onclick="setEffect('corners')" id="btn-corners" class="active">1. Turbo Rogi</button>
    <button onclick="setEffect('matrix')" id="btn-matrix">2. Matrix</button>
    <button onclick="setEffect('galaxy')" id="btn-galaxy">3. Galaktyka</button>
    <button onclick="setEffect('quantum')" id="btn-quantum">4. Glitch</button>
  </div>

  <script>
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let particles = [];
    let animationId = null;
    let targetPoints = [];
    let currentEffect = 'corners';

    // Konfiguracja tekstu
    const TEXT = "WIESZJAK";
    // Mniejszy krok = więcej cząsteczek (gęściej). 3 jest optymalne dla desktopu.
    const DENSITY_STEP = 3; 

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      calculateTargetPoints();
      // Restart current effect on resize
      initEffect(currentEffect);
    }

    function calculateTargetPoints() {
      // 1. Rysujemy tekst w pamięci, żeby zeskanować piksele
      ctx.fillStyle = '#fff';
      // Skalowanie czcionki do szerokości ekranu
      const fontSize = Math.min(width * 0.18, 250); 
      ctx.font = `900 ${fontSize}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      ctx.clearRect(0, 0, width, height);
      ctx.fillText(TEXT, width / 2, height / 2);

      const imgData = ctx.getImageData(0, 0, width, height);
      const data = imgData.data;
      targetPoints = [];

      // 2. Skanujemy piksele
      for (let y = 0; y < height; y += DENSITY_STEP) {
        for (let x = 0; x < width; x += DENSITY_STEP) {
          const alpha = data[(y * width + x) * 4 + 3];
          if (alpha > 128) {
            targetPoints.push({ x, y });
          }
        }
      }
      ctx.clearRect(0, 0, width, height);
    }

    // --- KLASY EFEKTÓW ---

    class Particle {
      constructor(tx, ty, effectType) {
        this.tx = tx; // Cel X
        this.ty = ty; // Cel Y
        this.joined = false;
        
        // Inicjalizacja zależna od efektu
        if (effectType === 'corners') {
          // Losowy róg ekranu
          const corner = Math.floor(Math.random() * 4);
          if (corner === 0) { this.x = 0; this.y = 0; }
          else if (corner === 1) { this.x = width; this.y = 0; }
          else if (corner === 2) { this.x = width; this.y = height; }
          else { this.x = 0; this.y = height; }
          
          this.vx = 0; 
          this.vy = 0;
          this.speed = 0.08 + Math.random() * 0.05; // Szybciej!
          this.color = `hsl(${40 + Math.random() * 20}, 100%, 60%)`; // Złoto/Żółty
          this.delay = Math.random() * 100; // Małe opóźnienie dla chaosu

        } else if (effectType === 'matrix') {
          this.x = tx; // X jest stały
          this.y = -Math.random() * height * 2; // Start wysoko nad ekranem
          this.speed = 5 + Math.random() * 15;
          this.color = '#0f0';
          this.head = Math.random() < 0.1; // Niektóre to "głowice" pociągu

        } else if (effectType === 'galaxy') {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.max(width, height); 
          this.x = width/2 + Math.cos(angle) * radius;
          this.y = height/2 + Math.sin(angle) * radius;
          this.angle = angle;
          this.radius = radius;
          this.speed = 0.02 + Math.random() * 0.02;
          this.orbitSpeed = 0.02;
          this.color = `hsl(${180 + Math.random()*60}, 100%, 70%)`; // Cyjan/Niebieski

        } else if (effectType === 'quantum') {
          this.x = tx;
          this.y = ty;
          this.color = '#fff';
          this.chaos = 50; // Amplituda drgań
        }
      }
    }

    // --- LOGIKA ANIMACJI ---

    function initEffect(type) {
      currentEffect = type;
      particles = targetPoints.map(p => new Particle(p.x, p.y, type));
      
      // Update UI buttons
      document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      document.getElementById(`btn-${type}`).classList.add('active');
    }

    function animate() {
      ctx.fillStyle = 'rgba(11, 15, 26, 0.3)'; // Smuga (motion blur)
      if (currentEffect === 'quantum') ctx.fillStyle = 'rgba(11, 15, 26, 1)'; // Bez smugi dla glitcha
      
      ctx.fillRect(0, 0, width, height);

      // Logika dla każdego efektu
      particles.forEach(p => {
        
        // --- 1. TURBO ROGI ---
        if (currentEffect === 'corners') {
           if (!p.joined) {
             p.x += (p.tx - p.x) * p.speed;
             p.y += (p.ty - p.y) * p.speed;
             
             // Snap to grid jeśli blisko
             if (Math.abs(p.tx - p.x) < 0.5 && Math.abs(p.ty - p.y) < 0.5) {
               p.x = p.tx;
               p.y = p.ty;
               p.joined = true;
             }
           }
           ctx.fillStyle = p.joined ? '#ffd700' : p.color;
           ctx.fillRect(p.x, p.y, 2, 2);
        }

        // --- 2. MATRIX ---
        else if (currentEffect === 'matrix') {
          if (p.y < p.ty) {
            p.y += p.speed;
          } else {
            p.y = p.ty; // Zablokuj na pozycji
          }
          
          ctx.fillStyle = p.y >= p.ty ? '#00ff00' : (Math.random() > 0.5 ? '#0f0' : '#cfc');
          // Rysuj jako znak lub prostokąt
          ctx.fillRect(p.x, p.y, 2, 6);
        }

        // --- 3. GALAKTYKA ---
        else if (currentEffect === 'galaxy') {
          // Zmniejszamy promień (zbliżamy do celu w sensie promienia)
          // Ale cel jest relatywny do środka, więc obliczamy odległość docelową
          const dx = p.tx - width/2;
          const dy = p.ty - height/2;
          const targetRadius = Math.sqrt(dx*dx + dy*dy);
          const targetAngle = Math.atan2(dy, dx);

          if (!p.joined) {
             p.radius -= (p.radius - targetRadius) * 0.05;
             p.angle += (targetAngle - p.angle) * 0.05; // Lerp kąta
             
             // Uproszczona fizyka spiralna
             p.x = width/2 + Math.cos(p.angle) * p.radius;
             p.y = height/2 + Math.sin(p.angle) * p.radius;

             if (Math.abs(p.radius - targetRadius) < 1) p.joined = true;
          } else {
            p.x = p.tx;
            p.y = p.ty;
          }
          
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 1, 0, Math.PI*2);
          ctx.fill();
        }

        // --- 4. QUANTUM GLITCH ---
        else if (currentEffect === 'quantum') {
           // Zmniejszaj chaos z czasem
           if (p.chaos > 0) p.chaos *= 0.98;
           
           const offsetX = (Math.random() - 0.5) * p.chaos;
           const offsetY = (Math.random() - 0.5) * p.chaos;
           
           // Kolory zmieniają się przy dużym chaosie
           if (p.chaos > 10) {
             ctx.fillStyle = Math.random() > 0.5 ? '#f0f' : '#0ff';
           } else {
             ctx.fillStyle = '#fff';
           }
           
           ctx.fillRect(p.x + offsetX, p.y + offsetY, 2, 2);
        }

      });

      animationId = requestAnimationFrame(animate);
    }

    // Obsługa przycisków
    window.setEffect = function(type) {
      initEffect(type);
    };

    // Start
    window.addEventListener('resize', resize);
    resize(); // To też odpali initEffect i calculatePoints
    animate();

  </script>
</body>
</html>